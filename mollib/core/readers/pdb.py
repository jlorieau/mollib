"""
Readers for Protein Databank Files.
"""
import re
from collections import OrderedDict

import numpy as np

from .. import settings as settings
from .base import MoleculeReader


# TODO: Make a faster reader with structs and binary, with a fallback
#       to the regex matcher.

class PDBRigidRegexReader(MoleculeReader):
    """A Molecule Reader for Protein Databank (PDB) files.
     
    PDBRigidRegexReader is a single-threaded Pythong implementation using a
    rigid structure regex that strictly follows the column width
    specifications of PDB files.
    """

    order = 0

    def __init__(self, urls=None, *args, **kwargs):
        if urls is None:
            self.urls = settings.pdb_urls
        super(PDBRigidRegexReader, self).__init__(*args, **kwargs)

    # The regex to match 'ATOM' and 'HETATM' lines. This regex is strict in
    # terms of the positioning of items.
    _re_atom = re.compile((r"(?P<type>ATOM  |HETATM)"
                           "(?P<number>[\s\d]{5}) "
                           "(?P<name>[\s\w]{4})"
                           "(?P<alt_loc>[\w\s])"
                           "(?P<residue_name>[\w\s]{3}) "
                           "(?P<chain>[\s\w]{1})"
                           "(?P<residue_number>[\s\w]{4})"
                           "(?P<icode>[\w\s])   "
                           "(?P<x>[\d\s\.\-]{8})"
                           "(?P<y>[\d\s\.\-]{8})"
                           "(?P<z>[\d\s\.\-]{8})"
                           "(?P<occupancy>[\d\s\.\-]{6})"
                           "(?P<B_factor>[\d\s\.\-]{6})          "
                           "(?P<element>[\s\w]{2})"
                           "(?P<charge>[\d\s\.\-]{2})?"))

    # The following are the conversion functions for the different matched items
    # in the _re_atom regex.
    _conversions = {'type': lambda x: str(x).strip(),
                    'number': int,
                    'name': lambda x: str(x).strip(),
                    'alt_loc': lambda x: str(x).strip(),
                    'residue_name': lambda x: str(x).strip(),
                    'chain': lambda x: str(x).strip(),
                    'residue_number': int,
                    'icode': lambda x: str(x).strip(),
                    'x': float,
                    'y': float,
                    'z': float,
                    'occupancy': float,
                    'B_factor': float,
                    'element': lambda x: str(x).strip(),
                    'charge': lambda x: float(x) if str(x).strip() else ''}

    # The regex to match 'CONECT' lines in a pdb file for bonding HETATM atoms.
    _re_conect = re.compile(r'^CONECT(?P<numbers>[\s\d]+)$')

    # The regex to match 'MODEL' lines in a pdb file.
    _re_model = re.compile(r'^MODEL\s+(?P<model_id>[\d]+)\s+$')

    def _match_atom(self, match, molecule):
        """Matches an ATOM or HETATM line in a PDB file and adds the matched
        atom to the molecule.

        Parameters
        ----------
        match: :obj:`re.MatchObject`.
            A regex match object generated by self._re_atom
        molecule: :obj:`mollib.Molecule`
            The molecule to add the matched atom to.

        .. note:: This function uses the string conversion functions in
                  self._conversions.
        """
        t = match.groups()
        # Convert types
        t = (str(t[0]).strip(),  # 0: type
             int(t[1]),     # 1: number
             str(t[2]).strip(),  # 2: name
             str(t[3]).strip(),  # 3: alt_loc
             str(t[4]).strip(),  # 4: residue_name
             str(t[5]).strip(),  # 5: chain
             int(t[6]),     # 6: residue_number
             str(t[7]).strip(),  # 7: icode
             float(t[8]),   # 8: x
             float(t[9]),   # 9: y
             float(t[10]),  # 10: z
             float(t[11]),  # 11: occupancy
             float(t[12]),  # 12: B-factor
             str(t[13]).strip(), # 13: element
             str(t[14]).strip(), # 14: charge
             #(float(t[14]) if t[14] and
             # str(t[14]).strip() else '')  # 14: charge
             )

        # Implementation 2: twice as slow as implementation 1
        # groupdict = {field_name: self._conversions[field_name](field_value)
        #              for field_name, field_value
        #              in match.groupdict().items()}
        #
        # Implementation 3: slower than implementaiton 2
        # Old implementation of string conversion using the slower convert(...)
        # groupdict = {field_name: convert(field_value)
        #              for field_name, field_value
        #              in match.groupdict().items()}

        # create Chain, if it doesn't already exist
        identifier = t[5]

        # If this is a HETATM, then append a '*' to the chain name so that
        # it doesn't overwrite protein chains.
        if t[0] == 'HETATM':
            identifier += '*'

        # Create a new chain, if it doesn't already exist
        if identifier not in molecule:
            chain = self.chain_class(identifier=identifier)
            chain.molecule = molecule
            molecule[identifier] = chain

        chain = molecule[identifier]

        # create Residue, if it doesn't already exist
        res_number, res_name, = t[6], t[4]

        if res_number not in chain:
            try:
                residue = self.residue_class(number=res_number, name=res_name)

                residue.chain = chain
                residue.molecule = molecule
                chain[res_number] = residue
            except KeyError:
                return None
        residue = chain[res_number]

        # create the Atom. The following code overwrites atoms duplicate
        # in atom name
        number, name, alt_loc, element = t[1], t[2], t[3], t[13]

        # Reformat the x/y/z coordinates to a numpy array
        pos = np.array(t[8:11])

        # Populate the new atom parameters and create the new Atom object.
        atom = self.atom_class(number=number, name=name, pos=pos,
                               element=element, residue=residue, chain=chain,
                               molecule=molecule)

        residue[name] = atom

    def _match_conect(self, match, molecule):
        """Matches a 'CONECT' line in a PDB file and populates the connections
        attribute.

        Parameters
        ----------
        match: :obj:`re.MatchObject`.
            A regex match object generated by self._re_conect
        molecule: :obj:`mollib.Molecule`
            The molecule to add the matched atom to.
        """
        # The CONECT line format uses fixed columns and some may be missing so
        # This line has to be broken into fixed pieces
        number_str = match.groupdict()['numbers']

        str_len = len(number_str)
        offset = -7 # This is for the stripped 'CONECT' string
        cols = [(7, 11), (12, 16), (17, 21), (22, 26), (27, 31), (32, 36),
                (37, 41), (42, 46), (47, 51), (52, 56), (57,61)]
        cols = [(i+offset, j+offset+1) for i,j in cols]

        atom_numbers = [number_str[i:j].strip()
                        if (i < str_len and j < str_len) else None
                        for i,j in cols]
        atom_numbers = [int(i) if i else None for i in atom_numbers]

        # The connections attribute is created by the molecule's __init__
        # function
        molecule.connections.append(atom_numbers)

    def _match_model(self, match, molecule):
        """Matches a MODEL line in a PDB file and sets the molecule's 'model_id'
        attribute.

        Parameters
        ----------
        match: :obj:`re.MatchObject`.
            A regex match object generated by self._re_model
        molecule:
            The molecule to set the match_id to.
        
        Returns
        -------
        model_id: int
            The model_id of the matched model
        """
        model_id = int(match.groupdict()['model_id'])
        molecule.model_id = model_id
        return model_id

    # The matchers have the starting string of matched items as keys, as a
    # tuple of the compiled regex and match processing functions.
    _matchers = OrderedDict((('ATOM', (_re_atom, _match_atom)),
                             ('MODEL', (_re_model, _match_model)),
                             ('CONECT', (_re_conect, _match_conect)),
                             ))

    def parse(self, stream, model_ids=None, *args, **kwargs):
        # Parse the arguments.

        # model_ids must be a list of integers
        if model_ids is not None and hasattr(model_ids, '__iter__'):
            model_ids = (model_ids, )
        if model_ids is not None and not all(isinstance(i, int)
                                             for i in model_ids):
            msg = ("The specified model ids must be integer numbers. The "
                   "values '{}' were received.")
            raise TypeError(msg.format(model_ids))

        # A list of regex matchers to harvest data from each line.
        # The first item is the regex to match. If there is a match,
        # the second item (function) will be called with the match
        matchers = self._matchers

        # Prepare the list of returned molecules
        molecules = []
        current_molecule = None

        # Find the ATOM/HETATM lines and pull out the necessary data
        for line in stream:
            # Placeholders for the regex match and the match processing function
            m, func = None, None

            # Gzipped files return bytes lines that have to be decoded
            if type(line) == bytes:
                line = line.decode('latin-1')

            # Advance the regex matching iterator
            for name, (regex, func) in matchers.items():
                m = regex.match(line)

                # If there's no match, nothing else can be done
                if not m:
                    continue

                # At this point, there is a match.

                # Set the current_molecule, if a molecule hasn't already been
                # specified (current_molecule is None) or a new model has been
                # specified.
                if m and (name == 'MODEL' or current_molecule is None):
                    current_molecule = self.molecule_class('tmp')
                    molecules.append(current_molecule)
                break

            # If line cannot be matched, skip this line.
            if m is None or func is None:
                continue

            # Parse the matched line.
            func(self, m, current_molecule)

        # The parsing is finished.
        # Now go through all of the molecules, and conduct needed processing
        # functions.
        for molecule in molecules:
            # Add prev_residue and next_residue pointers in the molecules.
            molecule.link_residues()

            # Set the atom topologies from the 'CONECT' records
            # TODO: This test should skip CONECT items if there are more than
            #       99,999 atoms
            molecule.set_atom_topologies()

        return molecules


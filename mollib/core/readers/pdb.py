"""
Readers for Protein Databank Files.
"""
import re

import numpy as np

from .base import MoleculeReader


class PDBRigidRegexReader(MoleculeReader):

    order = 0

    # The regex to match atom and hetatom lines. This regex is strict in terms
    # of the positioning of items
    _re_atom = re.compile((r"(?P<type>ATOM  |HETATM)"
                           "(?P<number>[\s\d]{5}) "
                           "(?P<name>[\s\w]{4})"
                           "(?P<alt_loc>[\w\s])"
                           "(?P<residue_name>[\w\s]{3}) "
                           "(?P<chain>[\s\w]{1})"
                           "(?P<residue_number>[\s\w]{4})"
                           "(?P<icode>[\w\s])   "
                           "(?P<x>[\d\s\.\-]{8})"
                           "(?P<y>[\d\s\.\-]{8})"
                           "(?P<z>[\d\s\.\-]{8})"
                           "(?P<occupancy>[\d\s\.\-]{6})"
                           "(?P<B_factor>[\d\s\.\-]{6})          "
                           "(?P<element>[\s\w]{2})"
                           "(?P<charge>[\d\s\.\-]{2})?"))

    # The following are the conversion functions for the different matched items
    # in the _re_atom regex.
    _conversions = {'type': lambda x: str(x).strip(),
                    'number': int,
                    'name': lambda x: str(x).strip(),
                    'alt_loc': lambda x: str(x).strip(),
                    'residue_name': lambda x: str(x).strip(),
                    'chain': lambda x: str(x).strip(),
                    'residue_number': int,
                    'icode': lambda x: str(x).strip(),
                    'x': float,
                    'y': float,
                    'z': float,
                    'occupancy': float,
                    'B_factor': float,
                    'element': lambda x: str(x).strip(),
                    'charge': lambda x: float(x) if str(x).strip() else ''}

    def _match_atom(self, match, molecule):
        """Matches an ATOM or HETATM line in a PDB file and adds the matched
        atom to the molecule.

        Parameters
        ----------
        match: :obj:`re.MatchObject`.
            A regex match object generated by self._re_atom
        molecule: :obj:`mollib.Molecule`
            The molecule to add the matched atom to.

        .. note:: This function uses the string conversion functions in
                  self._conversions.
        """
        t = match.groups()
        # Convert types
        t = (str(t[0]).strip(),  # 0: type
             int(t[1]),     # 1: number
             str(t[2]).strip(),  # 2: name
             str(t[3]).strip(),  # 3: alt_loc
             str(t[4]).strip(),  # 4: residue_name
             str(t[5]).strip(),  # 5: chain
             int(t[6]),     # 6: residue_number
             str(t[7]).strip(),  # 7: icode
             float(t[8]),   # 8: x
             float(t[9]),   # 9: y
             float(t[10]),  # 10: z
             float(t[11]),  # 11: occupancy
             float(t[12]),  # 12: B-factor
             str(t[13]).strip(), # 13: element
             str(t[14]).strip(), # 14: charge
             #(float(t[14]) if t[14] and
             # str(t[14]).strip() else '')  # 14: charge
             )

        # Implementation 2: twice as slow as implementation 1
        # groupdict = {field_name: self._conversions[field_name](field_value)
        #              for field_name, field_value
        #              in match.groupdict().items()}
        #
        # Implementation 3: slower than implementaiton 2
        # Old implementation of string conversion using the slower convert(...)
        # groupdict = {field_name: convert(field_value)
        #              for field_name, field_value
        #              in match.groupdict().items()}

        # create Chain, if it doesn't already exist
        identifier = t[5]

        # If this is a HETATM, then append a '*' to the chain name so that
        # it doesn't overwrite protein chains.
        if t[0] == 'HETATM':
            identifier += '*'

        # Create a new chain, if it doesn't already exist
        if identifier not in molecule:
            chain = self.chain_class(identifier=identifier)
            chain.molecule = molecule
            molecule[identifier] = chain

        chain = molecule[identifier]

        # create Residue, if it doesn't already exist
        res_number, res_name, = t[6], t[4]

        if res_number not in chain:
            try:
                residue = self.residue_class(number=res_number, name=res_name)

                residue.chain = chain
                residue.molecule = molecule
                chain[res_number] = residue
            except KeyError:
                return None
        residue = chain[res_number]

        # create the Atom. The following code overwrites atoms duplicate
        # in atom name
        number, name, alt_loc, element = t[1], t[2], t[3], t[13]

        # Reformat the x/y/z coordinates to a numpy array
        pos = np.array(t[8:11])

        # Populate the new atom parameters and create the new Atom object.
        atom = self.atom_class(number=number, name=name, pos=pos,
                               element=element, residue=residue, chain=chain,
                               molecule=molecule)

        residue[name] = atom

    def _match_conect(self, match, molecule):
        """Matches a 'CONECT' line in a PDB file and populates the connections
        attribute.

        Parameters
        ----------
        match: :obj:`re.MatchObject`.
            A regex match object generated by self._re_conect
        molecule: :obj:`mollib.Molecule`
            The molecule to add the matched atom to.
        """
        # The CONECT line format uses fixed columns and some may be missing so
        # This line has to be broken into fixed pieces
        number_str = match.groupdict()['numbers']

        str_len = len(number_str)
        offset = -7 # This is for the stripped 'CONECT' string
        cols = [(7, 11), (12, 16), (17, 21), (22, 26), (27, 31), (32, 36),
                (37, 41), (42, 46), (47, 51), (52, 56), (57,61)]
        cols = [(i+offset, j+offset+1) for i,j in cols]

        atom_numbers = [number_str[i:j].strip()
                        if (i < str_len and j < str_len) else None
                        for i,j in cols]
        atom_numbers = [int(i) if i else None for i in atom_numbers]

        # The connections attribute is created by the molecule's __init__
        # function
        molecule.connections.append(atom_numbers)

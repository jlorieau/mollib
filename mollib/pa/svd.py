# -*- coding: utf-8 -*-
"""
Functions to conduct the SVD on the RDCs and RACS.
"""
import numpy as np
from scipy import linalg

def Saupe_matrices(interaction_arrays, data):
    """Calculate the best-fit Saupe matrices for the given interaction_arrays
    and data.

    Parameters
    ----------
    interaction_arrays: list of dicts
        A list of dicts for each molecule to be fit.
        Each dict consists of the interaction label (ex: '14N-H') as keys and a
        5x1 array of the interaction values for the dipolar or chemical shift,
        generated by the process_molecule Process objects, as values.

    data: dicts
        A dict with the tensor key as keys, and a RDC
        or RACS datum as values.

    Returns
    -------
    Saupe_list: list
        A list of 5x1 Saupe matrices for each molecule/conformer.
    """
    assert isinstance(interaction_arrays, list)

    # Make an ordered list of the keys
    ordered_keys = sorted(data.keys())

    # Construct the A and D matrices
    A = []
    D = []
    for key in ordered_keys:
        for interaction_dict in interaction_arrays:
            if key not in interaction_dict:
                msg = ("The orientation for data point {} has not been "
                       "calculated.")
                raise Exception(msg.format(key))
            A.extend([interaction_dict[key]])

            expt_value = data[key].value
            expt_error = data[key].error
            D.append(expt_value)


    # Create an array from the A and D matrices
    A = np.array(A)
    D = np.array(D)

    # conduct the SVD on the A matrix
    U, w, V = linalg.svd(A, full_matrices=False)

    # Remove inf items from the inverted 'w' vector
    w_inv = 1./w
    for i in range(w_inv.size):
        w_inv[i] = 0. if np.isinf(w_inv[i]) else w_inv[i]
    w_inv = linalg.diagsvd(w_inv, w.shape[0], w.shape[0])

    # Calculate the S matrix
    A_inv = np.dot(V.transpose(), np.dot(w_inv, U.transpose()))
    S = np.dot(A_inv, D)

    # Calculate the A matrix for all the interactions in the interaction_dict.
    keys = {i for d in interaction_arrays for i in d.keys()}
    ordered_keys = sorted(keys)
    A = []
    for key in ordered_keys:
        for interaction_dict in interaction_arrays:
            if key not in interaction_dict:
                continue
            A.extend([interaction_dict[key]])

    D_pred = np.dot(A, S)

    # Calculate the predicted data. It must be sorted the same way as the
    # interaction_dict
    data_pred = {}
    for key, D in zip(ordered_keys, D_pred):
        data_pred[key] = D

    # Break up the S matrix into individual Saupe matrices, Das and Rh
    S_xyz = []
    Da, Dr, Rh = [], [], []
    for x in range(0, len(S), 5):
        s = S[x:x + 5]
        s_xyz = np.array([[-0.5 * (s[0] - s[1]), s[2], s[3], ],
                         [s[2], -0.5 * (s[0] + s[1]), s[4]],
                         [s[3], s[4], s[0]]])
        s_xyz = linalg.eigvals(s_xyz).real
        S_xyz.append(s_xyz)

        xx, yy, zz = [i for i in sorted(abs(s_xyz))]
        da = max(s_xyz) / 2. if max(s_xyz) == zz else min(s_xyz) / 2.
        dr = (yy - xx) / 3.
        Da.append(da)
        Dr.append(dr)
        Rh.append(dr / abs(da))

    return data_pred, S_xyz, Da, Dr, Rh

